### HashMap

#### 结构和底层原理

Jdk1.8之前为数组和链表，新的Entry节点在插入链表时，采用的头插法 8以后改为数组和链表 红黑树的结构，采用的是尾插法。

数组里每个地方都存放了Key-Value这样的实例，在java7中叫做Entry，java8中叫做Node。如下图所示：

![](/img/Node.png)

在put插入的时候会根据key的hash去计算一个index值，插入数组对应的位置。

#### 为什么还需呀链表？

hash存在概率性，可能两个key hash后值一样，这时形成了链表，头插法就是新来的值取代原来的值，原有的值就顺推到链表中了。因为写这个代码的作者认为后来的值被查找的可能性更大一点，提高查询效率。

#### 为什么1.8后改为尾插法？

首先我们看一下HashMap的**扩容机制**: 数组的长度是有限的，数据多次插入，达到一定的数量就会resize 。 那么什么时候进行resize呢？ 根据HashMap当前的长度和负载因子(默认0.75)。即 当数组长度为100时，存入第76个元素时需要resize

扩容步骤:
  - 创建一个新的Entry数组，长度是原数组的两倍
  - 便利原Entry数组，把所有的Entry重新Hash到新数组

**为什么重新Hash**

Hash的公式---> index = HashCode（Key） & （Length - 1）

所以长度变了的话index也不一样了。

**为什么改为尾插法了呢？**

在容量为2的容器里用不同线程插入ABC,假如我们在resize之前打个断点，执行完成后，可以看到链表的指向A->B->C ,如图所示:
![](/img/java/map1.png)

因为resize的赋值方式，也就是使用了**单链表的头插入方式，同一位置上新元素总是放在链表的头部位置。** 所以可能存在B的下一个指针指向了A。形成了环形链表，如图所示。
![](/img/java/map2.png)

使用**头插会改变链表的上的顺序**，但是如果使用尾插，**在扩容时会保持链表元素原本的顺序**，就不会出现链表成环的问题了。
![](/img/java/map3.png)


#### HashMap的初始化大小

16  为什么？？？？