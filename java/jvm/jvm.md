
## JVM (跨语言的平台)

### 特点 

- 一次编译，到处运行
- 自动内存管理
- 自动垃圾回收功能

### 基本概念

虚拟机的定义有2个，一种是类似Vmware的系统虚拟机，另一种是虚拟机称之为程序虚拟机，诸如JVM，CLR就是最常见到的虚拟机。
CLR：.Net的核心 公共语言运行库 
JVM(Java Virtual Machine)是可运行java代码(不仅仅java,Groovy,Scala,JavaScript等)的假想计算机，包括一套字节码指令集，一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域 。 JVM运行在操作系统上，与硬件没有直接的交互。
Java HotSpot Virtual Machine 成为java的默认虚拟机
![](/img/java/JVM位置.png)



### java代码执行流程

java源文件 通过编译器 可以生成字节码文件(.class文件) 然后通过不同平台的jvm(java虚拟机)中的解释器，编译成电脑能识别的机器码，从而实现一次编译 多次运行
(任何一个编程语言遵循Java虚拟机规范标准，通过自己的编译器生成的字节码文件遵循Java虚拟机规范标准都可以被java虚拟机解释运行)
也就是:
- java源文件  -> 编译器  ->字节码文件 
- 字节码文件 -> JVM -> 机器码
![](/img/java/classjvm.png)





JVM由三个主要的子系统构成 :
![](/img/java/jvm组成.png)
- 类加载机制  Class Loader
- 运行时数据区(内存机构) Runtime Data Area
    - 堆 （公有）
    - 栈   （线程独有）
    - 本地方法栈 （线程独有）
    - 方法区（元空间）  （公有）
    - 程序计数器 （线程独有）
  
- 执行引擎 (Execution Engline) 高级语言翻译成机器语言的角色

#### 堆

通过jvisualvm来查看jvm中的内存图

new出来的对象放在堆里（栈帧中的new出来局部内存变量存的是堆里的地址）

- JVM内存划分为堆内存和非堆内存，堆内存分为年轻代（Young Generation）、老年代（Old Generation），非堆内存就一个永久代（Permanent Generation）。
- 年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1。
- 堆内存用途：存放的是对象，垃圾收集器就是收集这些对象，然后根据GC算法回收。
- 非堆内存用途：永久代，也称为方法区，存储程序运行时长期存活的对象，比如类的元数据、方法、常量、属性等。

在JDK1.8版本废弃了永久代，替代的是元空间（MetaSpace），元空间与永久代上类似，都是方法区的实现，他们最大区别是：元空间并不在JVM中，而是使用本地内存。
元空间有注意有两个参数：
- MetaspaceSize ：初始化元空间大小，控制发生GC阈值
- MaxMetaspaceSize ： 限制元空间大小上限，防止异常占用过多物理内存
  
#####  为什么移除永久代？

移除永久代原因：为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。
有了元空间就不再会出现永久代OOM问题了！

![](/img/java/堆.png)
#### 栈

当线程运行时，栈会给该线程分配一块内存。
栈帧 ：执行main方法时会为里面变量分配一块空间。执行方法时也会分配一块空间

栈帧的内部成分:
局部变量表: 存放局部变量

操作数栈: 操作数（=右边的值）在程序执行运算中临时中转操作的内存区域

动态链接: 把符号引用转为直接引用（多态的指向）

方法出口:该方法执行完回到主线程哪一行



![](/img/java/栈帧.png)


#### 方法区（元空间）

常量+静态变量+类信息（xxx.class)

#### 本地方法栈

Thread 里的start()方法有一个start0方法，
```java
private native void start0();
```
字节码引擎会去系统底层去寻找类似xx.dll去执行

#### 程序计数器

当线程运行时，除了在栈分配一块内存时，也会分配一块程序计数器的内存空间。每个线程独有
存放当前代码正在运行的代码行号。程序计数器是动态变化的，由字节码执行引擎动态修改每个程序计数器的值。





### 类加载机制

.class文件 研究下机制
加载一个.class文件 需要三个步骤:
- 找到这个类
- 类加载器进行加载




### 双亲委派机制 

向上委托 向加载 
如何打破双亲委派？自己写一个类加载器。例子：tomcat (war包隔离)。热部署。
jdbc的spi


###  JVM运行时数据区分析



### GC日志实战分析



### JVM调优的目的

减少STW（stop the world )  

#### 什么是stop the world

jvm在执行垃圾收集时，会把所有的用户线程都停止。

####  为什么会设计成垃圾收集时，stop the world

如果不stop the world , 加入一个线程突然结束了，销毁所有的局部变量，这时已这些局部变量作为gc root 之前认定为非垃圾对象都变成了垃圾对象，会很乱
