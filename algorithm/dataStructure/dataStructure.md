# 红黑树

红黑树是一种含有红黑结点并能自平衡的二叉查找树。它必须满足下面性质:
- 每个结点要么是黑色，要么是红色
- 根结点是黑色
- 每个叶子结点(NIL)是黑色
- 每个红色结点的两个子结点一定都是黑色结点
-  任意一结点到每个叶子结点的路径都包含数量相同的黑节点 
  
通过第五特性可以推断出 如果一个结点存在黑色节结点，那么该结点肯定有两个子结点。  确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平
衡的二叉树。

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是 O(lgn),效率非常之高。例如，Java 集合中的TreeSet和TreeMap，C++ STL 中的 set、 map，以及 Linux 虚拟内存的管理，都是通过红黑树去实现的。

### 红黑树总是通过旋转和变色达到自平衡

- 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。如图3。
- 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。如图4。
- 变色：结点的颜色由红变黑或由黑变红。
  
![](/img/algorithm/左旋.png) 
![](/img/algorithm/右旋.png)

**左旋**只影响旋转结点和其**右子树**的结构，把右子树的结点往左子树挪了。

**右旋**只影响旋转结点和其**左子树**的结构，把左子树的结点往右子树挪了。


### 红黑树的查找

因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡

1. 从根结点开始查找，把根结点设置为当前结点；
2. 若当前结点为空，返回null；
3. 若当前结点不为空，用当前结点的key跟查找key作比较；
4. 若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；
5. 若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；
6. 若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；
 
 查找最坏时间复杂度为O(2lgN)


### 红黑树插入

插入操作包括两部分工作：一查找插入的位置；二插入后自平衡。查找插入的父结点很简单，跟查找操作区别不大。



### 红黑树删除

红黑树的删除操作也包括两部分工作：一查找目标结点；而删除后自平衡。